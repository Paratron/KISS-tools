<?
	/**
	*	CacheFly Easy Content Caching System.
	*
	*   This class helps you to cache dynamic parts of your website which are mostly generated by the same data to reduce database access and serverload.
	*	@author Christian Engel <hello@wearekiss.com>
	*	@version 1.2
	*/
	class kCacheFly
	{
		private $cFolder = "";
		private $caching = false;
		private $sqlConnection = null;
		private $sqlTable = "";
		private $cacheTimeout = 0;
		private $noOutput = false;
		/**
		*	Constructor
		*	@param string $cacheFolder Relative path to the cache folder. It needs to have write access for php - at least 644
		*/
		function __construct($cacheFolder)
		{
			if($cacheFolder != "") $this->cFolder = $cacheFolder; else $this->cError("You have to provide a cache folder");
			if(!is_writeable($cacheFolder)) $this->cError('Cache folder not accessible. Please set the appropriate file rights');
		}
		
		/**
		*	Initialisiert den Cache-Vorgang.
		*
		*	Wenn das Cache-Objekt nicht verfügbar ist wird der Cache-Recorder gestartet und true zurückgegeben. Wenn das Cache-Objekt verfügbar ist wird dieses eingebunden und es wird false zurückgegeben.
		*	Verwendungsbeispiel:
		*	<code>if($cFly->cache("cache_id"))
		*{
		*	//Code to Cache...
		*
		*	$cFly->stop();
		*}</code>
		*
		*	<b>Wichtig:</b><br />
		*	Es wird nur gecached was per echo {@link http://de3.php.net/manual/de/function.echo.php} an den Browser weitergegeben würde, die erzeugte Cache-Datei wäre also statisch.<br />
		*	Wenn in einer Cache-Datei Kleinigkeiten dynamisch bleiben sollen verwendet man statt der normalen <? ?> Tags für PHP spezielle Platzhalter für cacheFly: %? ?%.<br />
		*	Beispiel:
		*	<code><?
		*	//Irgendein Code
		*?>
		*%?= date("d.m.Y", time()); ?%
		*<?
		*	//Das war eben eine Ausgabe an den Browser, da die %? ?% Tags von PHP nicht interpretiert werden.
		*?>
		*</code>
		*	Die %? ?% Tags werden von cacheFly wieder in korrekte PHP-Tags umgewandelt und in die Cachedatei geschrieben.
		*
		*	<b>Cachen von reinen Daten, z.B. Arrays</b><br />
		*	Reine Daten sollen nicht beim User angezeigt werden, weshalb man cacheFly anweisen kann seine Daten nicht an den Browser zu schicken, nachdem der Cache-Vorgang abgeschlossen wurde.<br />
		*	Beispiel:
		*<code><?
		*	if($cFly->cache("eine_cache_id", 0, true))
		*	{
		*		$daten = array("a", "b", "c");
		*		echo serialize($daten);
		*		$cFly->stop();
		*	}
		*?>
		*</code>
		*	Dies verhindert die Ausgabe in Textform an den Besucher - das Array wird serialisiert in der Cachedatei abgespeichert.<br />
		*	Auslesen kann man es dann wieder auf folgende Art:
		*<code>
		*<?
		*	$daten = unserialize($cFly->getCacheObject("eine_cache_id));
		*?>
		* 
		*</code>
		*
		*	@param string $cacheID Eindeutige ID für das zu verwendende Cache-Objekt. String mit maximal 128 Zeichen, bestehend aus a-z, A-Z, 0-9, _, -, +, !
		*	@param integer $cacheExpires Optionaler Parameter, wann dieses Cache-Objekt seine Gültigkeit verliert und neu erzeugt werden soll. Angabe in Sekunden.
		*	@param boolean $noOutput Optionaler Parameter - Deaktiviert die Ausgabe des Caches an dieser Stelle; nutzbar um lediglich Informationen zu cachen.
		*	@return boolean Gibt true zurück, wenn der Cache inkonsistent ist und erneuert werden muss. Gibt false zurück, wenn der Cache  noch gültig ist und das CacheObjekt ausgegeben wurde.
		*/
		public function cache($cacheID, $cacheExpires = 0, $noOutput = false)
		{
			$error = false;
			if($this->caching) $error = $this->cError("Cache Recorder ist bereits aktiv!");
			if($cacheID == "") $error = $this->cError("Keine Cache-ID übergeben.");
			$gueltig = "a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 0 1 2 3 4 5 6 7 8 9 _ - + !";
			$gueltig = explode(" ", $gueltig);
			if(str_replace($gueltig, "", $cacheID) != "") $error = $this->cError("Ungültige Cache-ID!");
			
			if(!$error)
			{
				$fresh = false;
				
				if(file_exists($this->cFolder.$cacheID.".php"))
				{
					//Okay, CacheFile vorhanden.
					//Schon abgelaufen, wenn Zeit gegeben wurde?
					if($cacheExpires > 0)
					{
						if(filemtime($this->cFolder.$cacheID.".php") > time() - $cacheExpires) $fresh = true;
					}
					else $fresh = true;
				}
				
				if($fresh)
				{
					if(!$noOutput) include($this->cFolder.$cacheID.".php");
					flush();
					return false;
				}
				else
				{
					$this->caching = $cacheID;
					$this->cacheTimeout = $cacheExpires;
					$this->noOutput = $noOutput;
					ob_start();
					return true;
				}
			}
		}
		
		/**
		*	Beendet den Cache-Vorgang. Wird nur bei der Erzeugung eines Cache-Objekts benötigt.
		*	Der Cache-Vorgang wird erst mit dem Aufruf dieser Funktion abgeschlossen.
		*/
		public function stop()
		{
			$error = false;
			if(!$this->caching) $error = $this->cError("Cache Recorder ist nicht aktiv.");
			
			if(!$error)
			{
				$cacheString = ob_get_contents();
				ob_end_clean();
				$suchen = array("<%", "%>");
				$ersetzen = array("<?", "?>");
				$cacheString = str_replace($suchen, $ersetzen, $cacheString);
				$f = fopen($this->cFolder.$this->caching.".php", "w+");
				fwrite($f, $cacheString);
				fclose($f);
				
				if(!$this->noOutput) 
				{
					include($this->cFolder.$this->caching.".php");
					flush();
				}
				
				$this->caching = false;
				$this->cacheTimeout = 0;
				
			}
		}
		
		/**
		*	Zerstört das angegebene Cache-Objekt.
		*	@param string $cacheID Eindeutige ID für das zu verwendende Cache-Objekt. String mit maximal 128 Zeichen, bestehend aus a-z, A-Z, 0-9, _, -, +, !
		*	@return boolean
		*/
		public function clearCacheObject($cacheID)
		{
			$error = false;
			if($cacheID == "") $error = $this->cError("Keine Cache-ID übergeben.");
			$gueltig = "a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 0 1 2 3 4 5 6 7 8 9 _ - + !";
			$gueltig = explode(" ", $gueltig);
			if(str_replace($gueltig, "", $cacheID) != "") $error = $this->cError("Ungültige Cache-ID!");
			
			if(!$error)
			{
				if($this->sqlTable != "")
				{
					$sql = "DELETE FROM ".$this->sqlTable." WHERE cID = '".$cacheID."' LIMIT 1;";
					mysql_query($sql);
				}
				$result = @unlink($this->cFolder.$cacheID.".php");
				return $result;
			}
		}
		
		/**
		 * Gibt die Daten eines Cacheobjekts zurück.
		 * Vorsicht - diese Funktion prüft NICHT ob das Objekt noch Gültigkeit hat.
		 * 
		 * @param string $cacheID Eindeutige ID für das zu verwendende Cache-Objekt. String mit maximal 128 Zeichen, bestehend aus a-z, A-Z, 0-9, _, -, +, !
		 * @return string|false Gibt entweder den Inhalt des Cache-Objekts zurück, oder false wenn dieses nicht exisitiert.
		 */
		public function getCacheObject($cacheID)
		{
			$error = false;
			if($cacheID == "") $error = $this->cError("Keine Cache-ID übergeben.");
			$gueltig = "a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 0 1 2 3 4 5 6 7 8 9 _ - + !";
			$gueltig = explode(" ", $gueltig);
			if(str_replace($gueltig, "", $cacheID) != "") $error = $this->cError("Ungültige Cache-ID!");
			
			if(!$error)
			{
				if(file_exists($this->cFolder.$cacheID.".php"))
				{
					$daten = file_get_contents($this->cFolder.$cacheID.".php");
					return $daten;
				}
				else return false;
			}
			else return false;
		}
		
		/**
		*	Zerstört alle angelegten Cache-Objekte.
		*	@return boolean
		*/
		public function clearWholeCache()
		{
			if ($handle = opendir($this->cFolder))
			{
	
    			while (false !== ($file = readdir($handle))) 
    			{
        			if(is_file($this->cFolder."/".$file)) unlink($this->cFolder."/".$file);
    			}
	
	    		closedir($handle);
	    		return true;
			}
			else return false;
		}
		
		/**
		*	Zeigt eine Fehlermeldung an.
		*	@param string $errorText
		*	@return true
		*/
		private function cError($errorText)
		{
			echo "<h1>CacheFly Error</h1>";
			echo "<b>".$errorText."</b><br />";
			return true;
		}
	}
?>